<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>EBPF Malware Techniques on Mathscantor&#39;s Cybersecurity Blog</title>
    <link>https://mathscantor.github.io/series/ebpf-malware-techniques/</link>
    <description>Recent content in EBPF Malware Techniques on Mathscantor&#39;s Cybersecurity Blog</description>
    <generator>Hugo</generator>
    <language>en</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Sat, 26 Apr 2025 10:45:47 +0800</lastBuildDate>
    <atom:link href="https://mathscantor.github.io/series/ebpf-malware-techniques/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>eBPF Malware Techniques Part 3 - Hiding BPF Traces</title>
      <link>https://mathscantor.github.io/posts/ebpf-malware-techniques/ebpf-malware-techniques-part-3-hiding-bpf-traces/</link>
      <pubDate>Sat, 26 Apr 2025 10:45:47 +0800</pubDate>
      <guid>https://mathscantor.github.io/posts/ebpf-malware-techniques/ebpf-malware-techniques-part-3-hiding-bpf-traces/</guid>
      <description>&lt;h2 id=&#34;1-introduction&#34;&gt;1. Introduction&lt;/h2&gt;&#xA;&lt;p&gt;We&amp;rsquo;re finally gonna talk about the juicy stuff now that you are all geared up! Today, we are gonna go into a deep dive on how an eBPF application can hide itself and its child processes by understanding specific crucial Linux internals and how to circumvent them. I will be mainly using &lt;a href=&#34;https://github.com/eeriedusk/nysm&#34;&gt;&lt;em&gt;nysm&lt;/em&gt;&lt;/a&gt;, a eBPF-based malware as my prime example for hiding BPF traces.&lt;/p&gt;&#xA;&lt;h2 id=&#34;2-ebpf-enumeration-with-bpf-syscalls&#34;&gt;2. eBPF Enumeration with BPF Syscalls&lt;/h2&gt;&#xA;&lt;p&gt;When working with eBPF, it&amp;rsquo;s important to understand what&amp;rsquo;s actually loaded into the kernel at any point in time. Fortunately, &lt;em&gt;bpftool&lt;/em&gt; gives us powerful inspection capabilities through &lt;em&gt;bpf()&lt;/em&gt; syscalls., which we will take a deeper look in a second.&lt;/p&gt;</description>
    </item>
    <item>
      <title>eBPF Malware Techniques Part 2 - Setting Appropriate Hooks</title>
      <link>https://mathscantor.github.io/posts/ebpf-malware-techniques/ebpf-malware-techniques-part-2-setting-appropriate-hooks/</link>
      <pubDate>Fri, 11 Apr 2025 23:42:35 +0800</pubDate>
      <guid>https://mathscantor.github.io/posts/ebpf-malware-techniques/ebpf-malware-techniques-part-2-setting-appropriate-hooks/</guid>
      <description>&lt;h2 id=&#34;1-introduction&#34;&gt;1. Introduction&lt;/h2&gt;&#xA;&lt;p&gt;In my previous post, you were introduced to the 3 different major frameworks that eBPFs have to offer. I also briefly talked about how the logic of its hooks.&lt;/p&gt;&#xA;&lt;p&gt;To begin crafting your own eBPF-based malware, you need to understand where and what to hook on to. You don’t just throw an eBPF program into the void and hope it latches onto something juicy. No — you need a plan, a strategy, and most importantly, knowledge of the landscape.&lt;/p&gt;</description>
    </item>
    <item>
      <title>eBPF Malware Techniques Part 1 - Introduction</title>
      <link>https://mathscantor.github.io/posts/ebpf-malware-techniques/ebpf-malware-techniques-part-1-introduction/</link>
      <pubDate>Sat, 05 Apr 2025 09:20:03 +0800</pubDate>
      <guid>https://mathscantor.github.io/posts/ebpf-malware-techniques/ebpf-malware-techniques-part-1-introduction/</guid>
      <description>&lt;h2 id=&#34;1-background&#34;&gt;1. Background&lt;/h2&gt;&#xA;&lt;p&gt;As a cybersecurity researcher, understanding both traditional and modern methods of kernel-level code execution is crucial. Two prominent techniques you&amp;rsquo;ll encounter are LKM (Loadable Kernel Module) rootkits and eBPF-based applications.&lt;/p&gt;&#xA;&lt;p&gt;eBPF (extended Berkeley Packet Filter) is a Linux kernel technology that allows safe, user-defined code to run in kernel context. Originally intended for packet filtering, eBPF has evolved into a generic in-kernel virtual machine — enabling dynamic tracing, monitoring, networking, and even security enforcement.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
